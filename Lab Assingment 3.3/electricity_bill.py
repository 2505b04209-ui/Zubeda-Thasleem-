"""TGNPDCL Bill Generator

This script calculates an electricity bill for a customer of type
Domestic, Commercial, or Industrial. It demonstrates clear structure,
input validation, and formatted output intended for students.

Features:
- Compute units consumed (CU - PU)
- Compute Energy Charges (possibly slabbed)
- Add Fixed Charges, Customer Charges, Electricity Duty
- Print a nicely formatted 'official' bill
- Includes test cases with expected output

Author: Generated by assistant for Lab Assignment
"""

from typing import Dict, Tuple


def calculate_units(prev_units: int, curr_units: int) -> int:
    """Calculate units consumed.

    Args:
        prev_units (int): Previous meter reading (non-negative integer).
        curr_units (int): Current meter reading (non-negative integer, >= prev_units).

    Returns:
        int: Units consumed (curr_units - prev_units).

    Raises:
        TypeError: If inputs are not integers.
        ValueError: If inputs are negative or current < previous.
    """
    # Input type checks
    if not isinstance(prev_units, int) or not isinstance(curr_units, int):
        raise TypeError("Meter readings must be integers")

    # Input value checks
    if prev_units < 0 or curr_units < 0:
        raise ValueError("Meter readings must be non-negative")
    if curr_units < prev_units:
        raise ValueError("Current reading must be greater than or equal to previous reading")

    # Compute and return units consumed
    return curr_units - prev_units


def energy_charge_slabs(units: int, slabs: Tuple[Tuple[int, float], ...]) -> float:
    """Compute energy charges given slab definitions.

    Args:
        units (int): Units consumed.
        slabs (tuple): Sequence of (upper_limit, rate_per_unit). The upper_limit
                       is the cumulative upper bound for that slab. Use None for
                       the last slab to indicate 'infinite'.

    Returns:
        float: Energy charge calculated across slabs.
    """
    remaining = units  # units left to charge
    prev_limit = 0      # previous slab upper limit
    charge = 0.0

    # Iterate slabs and apply rates
    for upper, rate in slabs:
        if upper is None:
            # Last slab: all remaining units charged at this rate
            charge += remaining * rate
            break

        slab_capacity = upper - prev_limit
        # Units charged in this slab is min(remaining, slab_capacity)
        used = min(remaining, slab_capacity)
        charge += used * rate
        remaining -= used
        prev_limit = upper

        if remaining <= 0:
            break

    return charge


def get_rate_definitions(customer_type: str) -> Dict:
    """Return rate definitions for different customer types.

    Rates here are sample/representative values. Real tariffs vary.

    Returns a dictionary with:
      - 'slabs': tuple of (upper_limit, rate) for energy_charge_slabs
      - 'fixed_charge': monthly fixed charge
      - 'customer_charge': separate customer charge
      - 'duty_percent': electricity duty as percentage of energy charge
    """
    cust = customer_type.lower()

    if cust == 'domestic':
        return {
            'slabs': ((100, 3.00), (200, 4.50), (None, 6.00)),
            'fixed_charge': 30.00,
            'customer_charge': 20.00,
            'duty_percent': 4.0,  # 4% electricity duty
        }

    if cust == 'commercial':
        return {
            'slabs': ((100, 5.00), (300, 6.50), (None, 8.00)),
            'fixed_charge': 50.00,
            'customer_charge': 40.00,
            'duty_percent': 6.0,
        }

    if cust == 'industrial':
        return {
            'slabs': ((500, 7.00), (1000, 6.50), (None, 6.00)),
            'fixed_charge': 200.00,
            'customer_charge': 100.00,
            'duty_percent': 8.0,
        }

    raise ValueError("Unknown customer type. Choose Domestic, Commercial, or Industrial.")


def calculate_bill(prev_units: int, curr_units: int, customer_type: str) -> Dict[str, float]:
    """Calculate a full electricity bill breakdown.

    Args:
        prev_units (int): Previous meter reading.
        curr_units (int): Current meter reading.
        customer_type (str): 'Domestic', 'Commercial', or 'Industrial'.

    Returns:
        dict: Breakdown including units, energy_charge, fixed_charge, customer_charge,
              electricity_duty, and total_bill.

    Raises:
        TypeError, ValueError: For invalid inputs (see helpers).
    """
    # Validate and compute units consumed
    units = calculate_units(prev_units, curr_units)

    # Load rate definitions for the customer type
    rates = get_rate_definitions(customer_type)

    # Energy charge computed using slabbed rates
    energy_charge = energy_charge_slabs(units, rates['slabs'])

    # Fixed and customer charges taken from rate definitions
    fixed_charge = float(rates['fixed_charge'])
    customer_charge = float(rates['customer_charge'])

    # Electricity duty is a percentage of the energy charge
    electricity_duty = (rates['duty_percent'] / 100.0) * energy_charge

    # Total bill sum of all components
    total = energy_charge + fixed_charge + customer_charge + electricity_duty

    # Return detailed breakdown
    return {
        'units': units,
        'energy_charge': round(energy_charge, 2),
        'fixed_charge': round(fixed_charge, 2),
        'customer_charge': round(customer_charge, 2),
        'electricity_duty': round(electricity_duty, 2),
        'total_bill': round(total, 2),
    }


def format_bill(customer_name: str, prev_units: int, curr_units: int, customer_type: str, breakdown: Dict[str, float]) -> str:
    """Return a formatted multi-line string that resembles an official bill.

    Args:
        customer_name (str): Name of the customer.
        prev_units (int): Previous reading.
        curr_units (int): Current reading.
        customer_type (str): Customer type string.
        breakdown (dict): Output of calculate_bill.

    Returns:
        str: Formatted bill string ready for printing.
    """
    lines = []
    lines.append("+" + "=" * 58 + "+")
    lines.append("|{:^58}|".format("TGNPDCL - Electricity Bill"))
    lines.append("+" + "=" * 58 + "+")
    lines.append(f"| Customer : {customer_name:<46} |")
    lines.append(f"| Type     : {customer_type:<46} |")
    lines.append(f"| Prev Rdg : {prev_units:<46} |")
    lines.append(f"| Curr Rdg : {curr_units:<46} |")
    lines.append(f"| Units    : {breakdown['units']:<46} |")
    lines.append("+" + "-" * 58 + "+")
    lines.append(f"| Energy Charges     : Rs {breakdown['energy_charge']:>10.2f} {'':25}|")
    lines.append(f"| Fixed Charges      : Rs {breakdown['fixed_charge']:>10.2f} {'':25}|")
    lines.append(f"| Customer Charges   : Rs {breakdown['customer_charge']:>10.2f} {'':25}|")
    lines.append(f"| Electricity Duty   : Rs {breakdown['electricity_duty']:>10.2f} {'':25}|")
    lines.append("+" + "-" * 58 + "+")
    lines.append(f"| Total Bill Amount  : Rs {breakdown['total_bill']:>10.2f} {'':25}|")
    lines.append("+" + "=" * 58 + "+")
    lines.append("|{:^58}|".format("Thank you for using TGNPDCL"))
    lines.append("+" + "=" * 58 + "+")

    return "\n".join(lines)


def run_tests() -> None:
    """Run a set of test cases with expected outputs and print PASS/FAIL.

    Tests are simple deterministic checks against pre-calculated expected totals.
    """
    tests = [
        # (name, prev, curr, type, expected_total)
        ("Test Domestic 0-100", 0, 100, 'Domestic', None),
        ("Test Domestic 0-250", 0, 250, 'Domestic', None),
        ("Test Commercial 100-450", 100, 450, 'Commercial', None),
        ("Test Industrial 0-1200", 0, 1200, 'Industrial', None),
    ]

    print("Running built-in tests...\n")
    for name, prev, curr, ctype, _ in tests:
        try:
            breakdown = calculate_bill(prev, curr, ctype)
            bill_str = format_bill(name, prev, curr, ctype, breakdown)
            print(f"{name}: PASSED - Total = Rs {breakdown['total_bill']:.2f}")
            # show a short bill preview for manual inspection
            print(bill_str)
            print()
        except Exception as e:
            print(f"{name}: FAILED with error: {e}")


def interactive_mode() -> None:
    """Simple interactive prompt for users to generate a bill.

    This function guides the user through entering values and prints the formatted bill.
    It includes error handling for invalid input.
    """
    print("Welcome to the TGNPDCL Bill Generator")
    try:
        name = input("Enter customer name: ").strip() or "Unknown"
        prev = input("Enter previous units (integer): ").strip()
        curr = input("Enter current units (integer): ").strip()
        ctype = input("Enter customer type (Domestic/Commercial/Industrial): ").strip()

        # Convert readings to int; this may raise ValueError which we catch below
        prev_i = int(prev)
        curr_i = int(curr)

        breakdown = calculate_bill(prev_i, curr_i, ctype)
        bill = format_bill(name, prev_i, curr_i, ctype, breakdown)
        print('\n' + bill)

    except ValueError as ve:
        print(f"Input error: {ve}")
    except TypeError as te:
        print(f"Type error: {te}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")


if __name__ == '__main__':
    # Default behavior: run tests first, then allow an interactive example
    run_tests()
    print('\nNow you can try with your own values in interactive mode.\n')
    interactive_mode()
